<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System Rocket Physics Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
            color: #00ff00;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2000;
            pointer-events: none; /* Allow the simulation to be visible underneath */
        }

        #start-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 200px;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.9) 0%, rgba(0, 0, 0, 0.7) 50%, transparent 100%);
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            color: #00ff00;
            text-align: center;
            padding-bottom: 40px;
            pointer-events: auto;
        }

        #start-title {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff;
            font-weight: bold;
        }

        #start-subtitle {
            font-size: 1.1rem;
            margin-bottom: 1.5rem;
            color: #00ff00;
            max-width: 600px;
            line-height: 1.4;
        }

        #start-mission-btn {
            background: #00ff00;
            color: #000;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            box-shadow: 0 0 20px #00ff00;
            transition: all 0.3s ease;
            pointer-events: auto;
        }

        #start-mission-btn:hover {
            background: #44ff44;
            box-shadow: 0 0 30px #00ff00;
            transform: scale(1.05);
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #00ff00;
            min-width: 280px;
            font-size: 12px;
            transition: opacity 0.3s ease;
        }
        
        #ui.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .control-group {
            margin-bottom: 12px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #00ffff;
        }
        
        .control-row {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
        }
        
        button {
            background: #001100;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 6px 12px;
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
            border-radius: 3px;
        }
        
        button:hover {
            background: #006500;
        }
        
        button:active, button.active {
            background: #00ff00;
            color: #000;
        }
        
        .info {
            font-size: 11px;
            line-height: 1.5;
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 3px;
        }
        
        .fuel-bar {
            width: 100%;
            height: 12px;
            background: #333;
            border: 1px solid #00ff00;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 2px;
        }
        
        .fuel-fill {
            height: 100%;
            background: #00ff00;
            transition: width 0.3s, background-color 0.3s;
        }
        
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.9);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #00ff00;
            font-size: 10px;
            max-width: 320px;
            transition: opacity 0.3s ease;
        }
        
        #instructions.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .warning {
            color: #ff4444;
            font-weight: bold;
        }
        
        .good {
            color: #44ff44;
        }
        
        .caution {
            color: #ffff44;
        }

        #crash-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        #crash-content {
            background: #000;
            border: 2px solid #ff4444;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            color: #ff4444;
            font-size: 16px;
        }

        #crash-content h2 {
            color: #ff4444;
            margin-bottom: 20px;
        }

        #restart-btn {
            background: #ff4444;
            color: #000;
            border: none;
            padding: 10px 20px;
            font-size: 14px;
            cursor: pointer;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Start Screen -->
        <div id="start-screen">
            <div id="start-overlay">
                <h1 id="start-title">üöÄ Solar System Explorer</h1>
                <p id="start-subtitle">Navigate through the solar system using realistic physics and orbital mechanics</p>
                <button id="start-mission-btn">Start Mission</button>
            </div>
        </div>
        
        <div id="ui">
            <div class="control-group">
                <label>üöÄ Rocket Controls:</label>
                <div class="control-row">
                    <button id="thrustUp" data-key="ArrowUp">‚Üë Thrust</button>
                    <button id="rotateLeft" data-key="ArrowLeft">‚Ü∫ Left</button>
                    <button id="rotateRight" data-key="ArrowRight">‚Üª Right</button>
                </div>
            </div>
            
            <div class="control-group">
                <label>‚öôÔ∏è Simulation:</label>
                <div class="control-row">
                    <button id="resetRocket">Reset</button>
                    <button id="pausePlay">Pause</button>
                    <button id="followToggle">Follow: ON</button>
                </div>
            </div>
            
            <div class="control-group">
                <label>üîç Zoom:</label>
                <div class="control-row">
                    <button id="zoomIn">Zoom In</button>
                    <button id="zoomOut">Zoom Out</button>
                    <button id="resetZoom">Reset View</button>
                </div>
            </div>
            
            <div class="control-group">
                <label>üìä Telemetry:</label>
                <div class="info">
                    <div class="info-row">
                        <span>Speed:</span>
                        <span id="speed" class="good">0 km/s</span>
                    </div>
                    <div class="info-row">
                        <span>Altitude:</span>
                        <span id="altitude">0 km</span>
                    </div>
                    <div class="info-row">
                        <span>G-Force:</span>
                        <span id="gforce">0.0 G</span>
                    </div>
                    <div class="info-row">
                        <span>Nearest:</span>
                        <span id="nearest">Earth</span>
                    </div>
                    <div class="info-row">
                        <span>Fuel:</span>
                        <span id="fuel-percent">100%</span>
                    </div>
                    <div class="fuel-bar">
                        <div class="fuel-fill" id="fuel-fill"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="instructions">
            <strong>üéÆ Controls:</strong><br>
            ‚Ä¢ ‚Üë Arrow: Main thrust (uses fuel)<br>
            ‚Ä¢ ‚Üê ‚Üí Arrows: Rotate rocket<br>
            ‚Ä¢ Mouse: Pan view (disables follow)<br>
            ‚Ä¢ Scroll: Zoom in/out<br>
            ‚Ä¢ Space: Pause/unpause<br>
            ‚Ä¢ F: Toggle follow rocket<br>
            <br>
            <strong>‚ö†Ô∏è Physics:</strong><br>
            ‚Ä¢ Realistic orbital mechanics<br>
            ‚Ä¢ Fuel consumption & mass changes<br>
            ‚Ä¢ Asteroid field collisions<br>
            ‚Ä¢ Gravitational assists possible<br>
        </div>

        <div id="crash-modal">
            <div id="crash-content">
                <h2>MISSION FAILURE!</h2>
                <p id="crash-message">Your rocket has crashed!</p>
                <button id="restart-btn">Restart Mission</button>
            </div>
        </div>
    </div>

    <script>
        const stars = [];
        const G = 6.67430e-11;
        const TIME_SCALE = 100;

        const SUN_RADIUS = 6.9634e8;
        const SUN_MASS = 1.989e30;
        const MERCURY_RADIUS = 2.4397e6;
        const MERCURY_MASS = 3.3011e23;
        const VENUS_RADIUS = 6.0518e6;
        const VENUS_MASS = 4.8675e24;
        const EARTH_RADIUS = 6.371e6;
        const EARTH_MASS = 5.972e24;
        const MARS_RADIUS = 3.3895e6;
        const MARS_MASS = 6.4171e23;
        const JUPITER_RADIUS = 6.9911e7;
        const JUPITER_MASS = 1.898e27;
        const SATURN_RADIUS = 5.8232e7;
        const SATURN_MASS = 5.683e26;
        const URANUS_RADIUS = 2.5362e7;
        const URANUS_MASS = 8.681e25;
        const NEPTUNE_RADIUS = 2.4622e7;
        const NEPTUNE_MASS = 1.024e26;        const ROCKET_DRY_MASS = 5000;
        const FUEL_MASS = 15000;
        const THRUST_POWER = 150000;
        const FUEL_CONSUMPTION_RATE = 0.8; // Reduced fuel consumption for longer flights

        let rocketFuel = 100;
        let rocketThrust = 0;
        let angle = 90;
        let rocketVelocityX = 0;
        let rocketVelocityY = 0;
        let positionX = 0;
        let positionY = 0;

        let isPaused = false;
        let followRocket = true;
        let gameTime = 0;
        let keys = {};
        let lastTime = 0;
        let isStartScreen = true;
        let slowMotionFactor = 0.15; // For start screen slow motion - more visible effect

        // Add a global scale factor for planet distances
        const DISTANCE_SCALE = 1e-8; // Shrink distances by 100 million times

        function generateStars() {
            stars.length = 0; // Clear existing stars if regenerating
            for (let i = 0; i < 2500; i++) {
                stars.push({
                    x: (Math.random() - 0.5) * 4e13, // Much larger spread for stars
                    y: (Math.random() - 0.5) * 4e13,
                    brightness: Math.random() * 0.7 + 0.3,
                    size: Math.random() * 1.5 + 0.5
                });
            }
        }

        const celestialBodies = {
            sun: { 
                x: 0, y: 0, 
                mass: SUN_MASS, 
                radius: 30,
                color: '#ffff00',
                glow: true
            },
            mercury: { 
                x: 60, y: 0, 
                mass: MERCURY_MASS, 
                radius: 4,
                distance: 5.79e10, 
                period: 88 * 24 * 3600,
                angle: 0,
                color: '#8c7853'
            },
            venus: { 
                x: 120, y: 0, 
                mass: VENUS_MASS, 
                radius: 8,
                distance: 1.08e11, 
                period: 225 * 24 * 3600,
                angle: 45,
                color: '#ffc649'
            },
            earth: { 
                x: 200, y: 0, 
                mass: EARTH_MASS, 
                radius: 8,
                distance: 1.496e11, 
                period: 365 * 24 * 3600,
                angle: 90,
                color: '#6b93d6'
            },
            mars: { 
                x: 300, y: 0, 
                mass: MARS_MASS, 
                radius: 6,
                distance: 2.279e11, 
                period: 687 * 24 * 3600,
                angle: 135,
                color: '#cd5c5c'
            },
            jupiter: { 
                x: 400, y: 0, 
                mass: JUPITER_MASS, 
                radius: 18,
                distance: 7.786e11, 
                period: 4333 * 24 * 3600,
                angle: 180,
                color: '#d2691e'
            },
            saturn: { 
                x: 500, y: 0, 
                mass: SATURN_MASS, 
                radius: 16,
                distance: 1.432e12, 
                period: 10759 * 24 * 3600,
                angle: 225,
                color: '#fad5a5',
                hasRings: true
            },
            uranus: { 
                x: 600, y: 0, 
                mass: URANUS_MASS, 
                radius: 12,
                distance: 2.867e12, 
                period: 30687 * 24 * 3600,
                angle: 270,
                color: '#4fd0e7'
            },
            neptune: { 
                x: 700, y: 0, 
                mass: NEPTUNE_MASS, 
                radius: 12,
                distance: 4.515e12, 
                period: 60190 * 24 * 3600,
                angle: 315,
                color: '#4b70dd'
            }
        };

        // When initializing celestialBodies, multiply all 'distance' values by DISTANCE_SCALE
        // (Do this after celestialBodies is defined, before any position calculations)
        for (const key in celestialBodies) {
            if (celestialBodies[key].distance) {
                celestialBodies[key].distance *= DISTANCE_SCALE;
            }
        }

        // After celestialBodies definition, set static positions:
        celestialBodies.sun.x = 0;
        celestialBodies.sun.y = 0;
        celestialBodies.mercury.x = 60;
        celestialBodies.mercury.y = 0;
        celestialBodies.venus.x = 120;
        celestialBodies.venus.y = 0;
        celestialBodies.earth.x = 200;
        celestialBodies.earth.y = 0;
        celestialBodies.mars.x = 300;
        celestialBodies.mars.y = 0;
        celestialBodies.jupiter.x = 400;
        celestialBodies.jupiter.y = 0;
        celestialBodies.saturn.x = 500;
        celestialBodies.saturn.y = 0;
        celestialBodies.uranus.x = 600;
        celestialBodies.uranus.y = 0;
        celestialBodies.neptune.x = 700;
        celestialBodies.neptune.y = 0;
        // Set rocket spawn point relative to Earth
        positionX = celestialBodies.earth.x + 20;
        positionY = celestialBodies.earth.y;

        const asteroids = [];
        function generateAsteroids() {
            asteroids.length = 0; // Clear existing asteroids
            const minDistance = 3.0e11; // Adjusted: Inner edge of asteroid belt (after Mars)
            const maxDistance = 5.0e11; // Adjusted: Outer edge of asteroid belt (before Jupiter)
            const numAsteroids = 200;   // Reduced number for clarity
            
            for (let i = 0; i < numAsteroids; i++) {
                const distance = minDistance + Math.random() * (maxDistance - minDistance);
                const angle = Math.random() * Math.PI * 2;
                // Adjusted: Smaller radii for asteroids (0.5km to 2km)
                const radius = 500 + Math.random() * 1500; 
                
                // Assign a random grey color variation
                const baseGrey = 80 + Math.random() * 40; // Random base grey between 80 and 120
                const color = `rgb(${baseGrey}, ${baseGrey}, ${baseGrey})`;

                asteroids.push({
                    x: Math.cos(angle) * distance,
                    y: Math.sin(angle) * distance,
                    radius: radius, // World unit radius
                    mass: radius * radius * radius * 1500, // Adjusted density factor if needed
                    orbitalSpeed: Math.sqrt(G * SUN_MASS / distance),
                    orbitalAngle: angle,
                    distance: distance,
                    rotationSpeed: (Math.random() - 0.5) * 0.1,
                    color: color // Store the color
                });
            }
        }

        function calculateDistance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        function calculateGravitationalForce(bodyX, bodyY, bodyMass) {
            const dx = bodyX - positionX;
            const dy = bodyY - positionY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance === 0) return { fx: 0, fy: 0 };
            
            const currentMass = ROCKET_DRY_MASS + (rocketFuel / 100) * FUEL_MASS;
            const forceMagnitude = (G * bodyMass * currentMass) / (distance * distance);
            const unitX = dx / distance;
            const unitY = dy / distance;
            
            return {
                fx: forceMagnitude * unitX,
                fy: forceMagnitude * unitY
            };
        }

        function calculateThrustForce() {
            if (rocketThrust === 0 || rocketFuel <= 0) return { fx: 0, fy: 0 };
            
            const angleRad = (angle * Math.PI) / 180;
            return {
                fx: rocketThrust * Math.cos(angleRad),
                fy: rocketThrust * Math.sin(angleRad)
            };
        }        function updateRocketPhysics(deltaTime) {
            if (isPaused) return;

            // Apply slow motion during start screen
            if (isStartScreen) {
                deltaTime *= slowMotionFactor;
            }

            let totalFx = 0;
            let totalFy = 0;
            
            // Calculate gravitational forces from all celestial bodies
            for (const [, body] of Object.entries(celestialBodies)) {
                const force = calculateGravitationalForce(body.x, body.y, body.mass);
                totalFx += force.fx;
                totalFy += force.fy;
            }
            
            // Add thrust force
            const thrustForce = calculateThrustForce();
            totalFx += thrustForce.fx;
            totalFy += thrustForce.fy;
            
            // Consume fuel when thrusting - slower consumption
            if (rocketThrust > 0 && rocketFuel > 0) {
                const fuelUsed = FUEL_CONSUMPTION_RATE * deltaTime * (rocketThrust / THRUST_POWER) * 0.5; // Slower fuel consumption
                rocketFuel -= fuelUsed;
                if (rocketFuel <= 0) {
                    rocketFuel = 0;
                    rocketThrust = 0; // Stop thrust when out of fuel
                }
            }
            
            // Calculate acceleration and update velocity/position
            const totalMass = ROCKET_DRY_MASS + (rocketFuel / 100) * FUEL_MASS;
            const accelerationX = totalFx / totalMass;
            const accelerationY = totalFy / totalMass;
            
            rocketVelocityX += accelerationX * deltaTime;
            rocketVelocityY += accelerationY * deltaTime;
            
            positionX += rocketVelocityX * deltaTime;
            positionY += rocketVelocityY * deltaTime;

            gameTime += deltaTime;
        }

        function updateCelestialBodies(deltaTime) {
            if (isPaused) return;
            
            // Apply slow motion during start screen
            if (isStartScreen) {
                deltaTime *= slowMotionFactor;
            }
            
            for (const [, body] of Object.entries(celestialBodies)) {
                if (body.distance && body.period) {
                    body.angle += (2 * Math.PI / body.period) * deltaTime * TIME_SCALE;
                    const angleRad = body.angle * Math.PI / 180;
                    body.x = Math.cos(angleRad) * body.distance;
                    body.y = Math.sin(angleRad) * body.distance;
                }
            }
            
            for (const asteroid of asteroids) {
                asteroid.orbitalAngle += (asteroid.orbitalSpeed / asteroid.distance) * deltaTime * TIME_SCALE * 0.1;
                asteroid.x = Math.cos(asteroid.orbitalAngle) * asteroid.distance;
                asteroid.y = Math.sin(asteroid.orbitalAngle) * asteroid.distance;
            }
        }        function checkCollisions() {
            // Check collisions with celestial bodies
            for (const [name, body] of Object.entries(celestialBodies)) {
                const distance = calculateDistance(positionX, positionY, body.x, body.y);
                if (distance < body.radius + 5000) { // 5km safety margin
                    showCrashModal(`Mission Failed! Crashed into ${name.charAt(0).toUpperCase() + name.slice(1)}!`);
                    return;
                }
            }
            
            // Check collisions with asteroids
            for (const asteroid of asteroids) {
                const distance = calculateDistance(positionX, positionY, asteroid.x, asteroid.y);
                if (distance < asteroid.radius + 5000) { // 5km safety margin
                    showCrashModal('Mission Failed! Hit asteroid!');
                    return;
                }
            }
        }

        function showCrashModal(message) {
            document.getElementById('crash-message').textContent = message;
            document.getElementById('crash-modal').style.display = 'flex';
            isPaused = true;
        }        function resetRocket() {
            rocketThrust = 0;
            
            // Make sure celestial bodies are at their current positions
            for (const [name, body] of Object.entries(celestialBodies)) {
                if (body.distance && body.period && name !== 'sun') {
                    body.x = Math.cos(body.angle * Math.PI / 180) * body.distance;
                    body.y = Math.sin(body.angle * Math.PI / 180) * body.distance;
                }
            }
            
            // Start the rocket in stable Earth orbit at a safe distance (400km altitude)
            const earthOrbitRadius = EARTH_RADIUS + 400000; // 400km altitude from Earth surface
            positionX = celestialBodies.earth.x + earthOrbitRadius; // Position relative to Earth's current location
            positionY = celestialBodies.earth.y;
            
            // Calculate Earth's orbital velocity around the Sun
            const earthSunDistance = calculateDistance(celestialBodies.earth.x, celestialBodies.earth.y, 0, 0);
            const earthOrbitalSpeed = Math.sqrt(G * SUN_MASS / earthSunDistance);
            
            // Earth's velocity vector (tangent to its orbit around Sun)
            const earthVelX = -earthOrbitalSpeed * (celestialBodies.earth.y / earthSunDistance);
            const earthVelY = earthOrbitalSpeed * (celestialBodies.earth.x / earthSunDistance);
            
            // Rocket's orbital velocity around Earth for stable circular orbit
            const rocketOrbitalSpeed = Math.sqrt(G * EARTH_MASS / earthOrbitRadius);
            
            // Calculate proper tangent velocity for stable orbit
            // Rocket position relative to Earth
            const relativeX = positionX - celestialBodies.earth.x;
            const relativeY = positionY - celestialBodies.earth.y;
            const relativeDistance = Math.sqrt(relativeX * relativeX + relativeY * relativeY);
            
            // Tangent direction (perpendicular to radius vector)
            const tangentX = -relativeY / relativeDistance;
            const tangentY = relativeX / relativeDistance;
            
            // Rocket velocity relative to Earth (in tangent direction for stable orbit)
            const rocketVelX = rocketOrbitalSpeed * tangentX;
            const rocketVelY = rocketOrbitalSpeed * tangentY;
            
            // Total velocity is Earth's orbital velocity plus rocket's orbital velocity around Earth
            rocketVelocityX = earthVelX + rocketVelX;
            rocketVelocityY = earthVelY + rocketVelY;
            
            angle = Math.atan2(tangentY, tangentX) * 180 / Math.PI; // Point in direction of motion
            rocketFuel = 100;
            followRocket = true;
            isPaused = false;
            updateFollowButton();
            camera.zoom = 5e-4; // Zoom in much closer to see rocket better
            camera.panX = 0;
            camera.panY = 0;
            document.getElementById('crash-modal').style.display = 'none';
            document.getElementById('pausePlay').textContent = 'Pause';
            gameTime = 0;
            
            console.log('Rocket reset at altitude:', (earthOrbitRadius - EARTH_RADIUS) / 1000, 'km');
            console.log('Orbital speed:', rocketOrbitalSpeed / 1000, 'km/s');
        }

        function togglePause() {
            isPaused = !isPaused;
            document.getElementById('pausePlay').textContent = isPaused ? 'Play' : 'Pause';
        }

        function toggleFollowRocket() {
            followRocket = !followRocket;
            updateFollowButton();
        }

        function updateFollowButton() {
            document.getElementById('followToggle').textContent = `Follow: ${followRocket ? 'ON' : 'OFF'}`;
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        if (!canvas || !ctx) {
            console.error('Failed to initialize canvas or 2D context');
        } else {
            console.log('Canvas and context initialized successfully');
        }

        const camera = {
            x: positionX,
            y: positionY,
            zoom: 0.7, // Default, will be overridden by init() or resetRocket()
            panX: 0,
            panY: 0,
            minZoom: 1e-15, // Much smaller min zoom to allow seeing the entire solar system
            maxZoom: 5e-4
        };

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            console.log('Canvas resized to:', canvas.width, 'x', canvas.height);
        }

        function worldToScreen(worldX, worldY) {
            const screenX = (worldX - camera.x + camera.panX) * camera.zoom + canvas.width / 2;
            const screenY = (worldY - camera.y + camera.panY) * camera.zoom + canvas.height / 2;
            return { x: screenX, y: screenY };
        }        function drawStars() {
            ctx.save();
            ctx.fillStyle = '#ffffff'; // Stars are white
            let starsDrawn = 0;
            for (const star of stars) {
                const screenPos = worldToScreen(star.x, star.y);

                // Basic culling: only draw if near viewport
                if (screenPos.x < -5 || screenPos.x > canvas.width + 5 ||
                    screenPos.y < -5 || screenPos.y > canvas.height + 5) {
                    continue;
                }

                ctx.globalAlpha = star.brightness;
                
                // Draw small circles for stars. star.size is intended as pixel diameter.
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, star.size / 2, 0, Math.PI * 2);
                ctx.fill();
                starsDrawn++;
            }
            
            if (gameTime < 1) {
                console.log(`Drew ${starsDrawn} stars out of ${stars.length} total`);
            }
            
            ctx.globalAlpha = 1.0; // Reset globalAlpha
            ctx.restore();
        }

        function drawCelestialBody(body, name) {
            const screenPos = worldToScreen(body.x, body.y);
            // Make planets and sun much smaller during start screen preview
            let baseRadius;
            if (isStartScreen) {
                baseRadius = body.radius * 100; // Much smaller for preview
            } else {
                baseRadius = body.radius * 10000; // Normal size for simulation
            }
            const screenRadius = Math.max(2, baseRadius * camera.zoom);

            // Debug logging for every frame
            console.log(`Drawing ${name}: world(${body.x.toExponential(2)}, ${body.y.toExponential(2)}) -> screen(${screenPos.x.toFixed(1)}, ${screenPos.y.toFixed(1)}), radius: ${screenRadius.toFixed(1)}`);

            if (screenPos.x > -screenRadius * 3 && screenPos.x < canvas.width + screenRadius * 3 &&
                screenPos.y > -screenRadius * 3 && screenPos.y < canvas.height + screenRadius * 3) {
                if (body.glow) {
                    const gradient = ctx.createRadialGradient(screenPos.x, screenPos.y, 0, screenPos.x, screenPos.y, screenRadius * 3);
                    gradient.addColorStop(0, body.color);
                    gradient.addColorStop(0.5, body.color + '44');
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(screenPos.x, screenPos.y, screenRadius * 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.fillStyle = body.color;
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, screenRadius, 0, Math.PI * 2);
                ctx.fill();
                if (body.hasRings && screenRadius > 5) {
                    ctx.strokeStyle = '#aaaaaa';
                    ctx.lineWidth = Math.max(1, screenRadius * 0.05);
                    ctx.beginPath();
                    ctx.arc(screenPos.x, screenPos.y, screenRadius * 1.8, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(screenPos.x, screenPos.y, screenRadius * 2.2, 0, Math.PI * 2);
                    ctx.stroke();
                }
                if (screenRadius > 5) {
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${Math.max(10, screenRadius * 0.3)}px Courier New`;
                    ctx.textAlign = 'center';
                    ctx.fillText(name.charAt(0).toUpperCase() + name.slice(1), screenPos.x, screenPos.y - screenRadius - 15);
                }
            } else {
                console.log(`${name} is outside viewport bounds`);
            }
        }

        function drawAsteroid(asteroid) {
            const screenPos = worldToScreen(asteroid.x, asteroid.y);
            // Make asteroids more visible during start screen
            let baseRadius = asteroid.radius * 300;
            if (isStartScreen) {
                baseRadius = asteroid.radius * 100; // 100x larger during start screen
            }
            const screenRadius = Math.max(0.5, baseRadius * camera.zoom); 
            
            // Culling - expanded slightly to catch asteroids just off screen if they are large
            if (screenPos.x > -screenRadius - 5 && screenPos.x < canvas.width + screenRadius + 5 &&
                screenPos.y > -screenRadius - 5 && screenPos.y < canvas.height + screenRadius + 5) {
                
                ctx.fillStyle = asteroid.color; // Use the pre-calculated color
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, screenRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Keep simple detail for performance, only if reasonably large on screen
                if (screenRadius > 2) { 
                    const baseGreyValue = parseInt(asteroid.color.substring(asteroid.color.indexOf('(') + 1, asteroid.color.indexOf(',')));
                    const detailBrightness = Math.min(255, baseGreyValue + 30); // A bit brighter for detail
                    ctx.fillStyle = `rgb(${detailBrightness},${detailBrightness},${detailBrightness})`;
                    // Draw a smaller, slightly offset circle for a bit of texture
                    ctx.beginPath();
                    ctx.arc(screenPos.x + screenRadius * 0.2, screenPos.y - screenRadius * 0.2, screenRadius * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawRocket() {
            const screenPos = worldToScreen(positionX, positionY);
            // Make rocket more visible during start screen by using a larger size
            const baseSize = isStartScreen ? 60 : 15;
            const size = Math.max(8, baseSize * Math.sqrt(camera.zoom * 50000));
            
            ctx.save();
            ctx.translate(screenPos.x, screenPos.y);
            ctx.rotate(angle * Math.PI / 180);
            
            ctx.fillStyle = '#ff4444';
            ctx.beginPath();
            ctx.moveTo(size, 0);
            ctx.lineTo(-size * 0.6, size * 0.4);
            ctx.lineTo(-size * 0.6, -size * 0.4);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = Math.max(1, size * 0.1);
            ctx.stroke();
            
            if (rocketThrust > 0) {
                const flameLength = (rocketThrust / THRUST_POWER) * size * 2;
                ctx.fillStyle = '#ff8800';
                ctx.beginPath();
                ctx.moveTo(-size * 0.6, size * 0.3);
                ctx.lineTo(-size * 0.6 - flameLength, 0);
                ctx.lineTo(-size * 0.6, -size * 0.3);
                ctx.closePath();
                ctx.fill();
                
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.moveTo(-size * 0.6, size * 0.15);
                ctx.lineTo(-size * 0.6 - flameLength * 0.7, 0);
                ctx.lineTo(-size * 0.6, -size * 0.15);
                ctx.closePath();
                ctx.fill();
            }
            
            ctx.restore();
        }

        function drawVelocityVector() {
            const screenPos = worldToScreen(positionX, positionY);
            const speed = Math.sqrt(rocketVelocityX * rocketVelocityX + rocketVelocityY * rocketVelocityY);
            
            if (speed > 0) {
                const scale = Math.min(100, speed / 200);
                const endX = screenPos.x + (rocketVelocityX / speed) * scale;
                const endY = screenPos.y + (rocketVelocityY / speed) * scale;
                
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(screenPos.x, screenPos.y);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                
                const angle = Math.atan2(endY - screenPos.y, endX - screenPos.x);
                ctx.fillStyle = '#00ff00';
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(endX - 6 * Math.cos(angle - 0.5), endY - 6 * Math.sin(angle - 0.5));
                ctx.lineTo(endX - 6 * Math.cos(angle + 0.5), endY - 6 * Math.sin(angle + 0.5));
                ctx.closePath();
                ctx.fill();
            }
        }

        function updateCamera() {
            if (followRocket && !isStartScreen) {
                camera.x = positionX;
                camera.y = positionY;
            }
        }        function updateUI() {
            const speed = Math.sqrt(rocketVelocityX * rocketVelocityX + rocketVelocityY * rocketVelocityY) / 1000;
            const speedEl = document.getElementById('speed');
            speedEl.textContent = `${speed.toFixed(1)} km/s`;
            
            if (speed < 5) {
                speedEl.className = 'warning';
            } else if (speed < 12) {
                speedEl.className = 'good';
            } else {
                speedEl.className = 'caution';
            }
            
            // Find nearest celestial body
            let nearestBody = 'sun';
            let nearestDistance = calculateDistance(positionX, positionY, 0, 0);
            for (const [name, body] of Object.entries(celestialBodies)) {
                const distance = calculateDistance(positionX, positionY, body.x, body.y);
                if (distance < nearestDistance) {
                    nearestDistance = distance;
                    nearestBody = name;
                }
            }
            
            document.getElementById('nearest').textContent = nearestBody.charAt(0).toUpperCase() + nearestBody.slice(1);
            
            // Calculate altitude properly
            if (nearestBody === 'earth') {
                const altitude = (nearestDistance - EARTH_RADIUS) / 1000;
                document.getElementById('altitude').textContent = `${altitude.toFixed(0)} km`;
            } else {
                document.getElementById('altitude').textContent = `${(nearestDistance / 1000).toFixed(0)} km`;
            }
            
            // Calculate total acceleration (G-force) from all forces
            let totalFx = 0;
            let totalFy = 0;
            
            // Add gravitational forces from all bodies
            for (const [, body] of Object.entries(celestialBodies)) {
                const force = calculateGravitationalForce(body.x, body.y, body.mass);
                totalFx += force.fx;
                totalFy += force.fy;
            }
            
            // Add thrust force
            const thrustForce = calculateThrustForce();
            totalFx += thrustForce.fx;
            totalFy += thrustForce.fy;
            
            // Calculate total acceleration
            const totalMass = ROCKET_DRY_MASS + (rocketFuel / 100) * FUEL_MASS;
            const totalAcceleration = Math.sqrt(totalFx * totalFx + totalFy * totalFy) / totalMass;
            const gForce = totalAcceleration / 9.81;
            
            document.getElementById('gforce').textContent = `${gForce.toFixed(1)} G`;
            
            // Update fuel display
            document.getElementById('fuel-percent').textContent = `${Math.round(rocketFuel)}%`;
            const fuelFill = document.getElementById('fuel-fill');
            fuelFill.style.width = `${rocketFuel}%`;
            
            if (rocketFuel < 20) {
                fuelFill.style.backgroundColor = '#ff4444';
            } else if (rocketFuel < 50) {
                fuelFill.style.backgroundColor = '#ffff44';
            } else {
                fuelFill.style.backgroundColor = '#00ff00';
            }
        }

        function gameLoop(currentTime) {
            if (!currentTime) currentTime = performance.now();
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;
            
            // Debug logging for first few frames
            if (gameTime < 1) {
                console.log(`Frame: time=${gameTime.toFixed(2)}, camera zoom=${camera.zoom.toExponential(2)}, camera pos=(${camera.x.toExponential(2)}, ${camera.y.toExponential(2)})`);
            }
            
            updateRocketPhysics(deltaTime);
            updateCelestialBodies(deltaTime);
            checkCollisions();
            
            updateCamera();
            
            // Clear canvas with dark space color
            ctx.fillStyle = '#000011';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw everything
            drawStars();
            
            let planetsDrawn = 0;
            for (const [name, body] of Object.entries(celestialBodies)) {
                drawCelestialBody(body, name);
                planetsDrawn++;
            }
            
            if (gameTime < 1) {
                console.log(`Drew ${planetsDrawn} celestial bodies, ${asteroids.length} asteroids available`);
            }
            
            for (const asteroid of asteroids) {
                drawAsteroid(asteroid);
            }
            
            drawRocket();
            drawVelocityVector();
            
            updateUI();
            
            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            
            if (e.code === 'Space') {
                e.preventDefault();
                togglePause();
            } else if (e.code === 'KeyF') {
                e.preventDefault();
                toggleFollowRocket();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });        function handleInput() {
            if (isPaused || isStartScreen) return; // Disable input during start screen
            
            // Thrust control - gradual buildup for better control
            if (keys['ArrowUp'] && rocketFuel > 0) {
                rocketThrust = Math.min(rocketThrust + THRUST_POWER * 0.1, THRUST_POWER);
                document.getElementById('thrustUp').classList.add('active');
            } else {
                rocketThrust = Math.max(rocketThrust - THRUST_POWER * 0.2, 0);
                document.getElementById('thrustUp').classList.remove('active');
            }
            
            // Rotation control - more responsive
            if (keys['ArrowLeft']) {
                angle -= 3;
                document.getElementById('rotateLeft').classList.add('active');
            } else {
                document.getElementById('rotateLeft').classList.remove('active');
            }
            
            if (keys['ArrowRight']) {
                angle += 3;
                document.getElementById('rotateRight').classList.add('active');
            } else {
                document.getElementById('rotateRight').classList.remove('active');
            }
            
            // Normalize angle
            if (angle < 0) angle += 360;
            if (angle >= 360) angle -= 360;
        }

        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            followRocket = false;
            updateFollowButton();
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            
            camera.panX += deltaX / camera.zoom;
            camera.panY += deltaY / camera.zoom;
            
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            camera.zoom = Math.max(camera.minZoom, Math.min(camera.maxZoom, camera.zoom * zoomFactor));
        });

        document.getElementById('resetRocket').addEventListener('click', resetRocket);
        document.getElementById('pausePlay').addEventListener('click', togglePause);
        document.getElementById('followToggle').addEventListener('click', toggleFollowRocket);

        document.getElementById('zoomIn').addEventListener('click', () => {
            camera.zoom = Math.min(camera.maxZoom, camera.zoom * 1.5);
        });

        document.getElementById('zoomOut').addEventListener('click', () => {
            camera.zoom = Math.max(camera.minZoom, camera.zoom * 0.67);
        });

        document.getElementById('resetZoom').addEventListener('click', () => {
            camera.zoom = 1e-4;
            camera.panX = 0;
            camera.panY = 0;
            followRocket = true;
            updateFollowButton();
        });

        document.getElementById('restart-btn').addEventListener('click', resetRocket);

        // Start screen functionality - setup the button event listener
        document.addEventListener('DOMContentLoaded', () => {
            const startButton = document.getElementById('start-mission-btn');
            if (startButton) {
                console.log('Setting up start button');
                startButton.addEventListener('click', () => {
                    console.log('Start mission button clicked');
                    const startScreen = document.getElementById('start-screen');
                    isStartScreen = false;
                    
                    // Hide start screen with fade out
                    startScreen.style.opacity = '0';
                    startScreen.style.transition = 'opacity 0.5s ease';
                    setTimeout(() => {
                        startScreen.style.display = 'none';
                    }, 500);
                    
                    // Animate zoom in to rocket over 2 seconds
                    const animationDuration = 2000; // 2 seconds
                    const startTime = Date.now();
                    const startZoom = camera.zoom;
                    const targetZoom = 5e-4; // Final zoom level for gameplay
                    const startX = camera.x;
                    const startY = camera.y;
                    
                    console.log('Starting zoom animation from zoom:', startZoom, 'to:', targetZoom);
                    
                    function animateZoomToRocket() {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / animationDuration, 1);
                        
                        // Smooth easing function
                        const easeInOut = t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                        const easedProgress = easeInOut(progress);
                        
                        // Interpolate zoom and position
                        camera.zoom = startZoom + (targetZoom - startZoom) * easedProgress;
                        camera.x = (1 - easedProgress) * startX + easedProgress * positionX;
                        camera.y = (1 - easedProgress) * startY + easedProgress * positionY;
                        
                        if (progress < 1) {
                            requestAnimationFrame(animateZoomToRocket);
                        } else {
                            // Animation complete - enable rocket following and full speed
                            followRocket = true;
                            updateFollowButton();
                            slowMotionFactor = 1.0; // Return to normal speed
                            
                            // Show UI after zoom animation completes
                            const ui = document.getElementById('ui');
                            const instructions = document.getElementById('instructions');
                            ui.classList.remove('hidden');
                            instructions.classList.remove('hidden');
                            ui.style.opacity = '0';
                            instructions.style.opacity = '0';
                            setTimeout(() => {
                                ui.style.transition = 'opacity 0.7s';
                                instructions.style.transition = 'opacity 0.7s';
                                ui.style.opacity = '1';
                                instructions.style.opacity = '1';
                            }, 10);
                            
                            console.log('Zoom animation complete. Rocket following enabled.');
                        }
                    }
                    
                    animateZoomToRocket();
                });
            } else {
                console.error('Start mission button not found!');
            }
        });

        function init() {
            console.log('Init function called');
            
            // Ensure canvas is properly sized first
            resizeCanvas();
            
            // Test canvas by drawing a simple red rectangle
            ctx.fillStyle = 'red';
            ctx.fillRect(100, 100, 200, 100);
            console.log('Test rectangle drawn');
            
            console.log('Starting initialization');
            generateStars();
            generateAsteroids();
            
            // Initialize celestial body positions
            for (const [, body] of Object.entries(celestialBodies)) {
                if (body.distance && body.period) {
                    const angleRad = body.angle * Math.PI / 180;
                    body.x = Math.cos(angleRad) * body.distance;
                    body.y = Math.sin(angleRad) * body.distance;
                }
            }
            
            // Initialize rocket in proper Earth orbit
            resetRocket();
            
            // Set preview zoom so Mercury's orbit is ~60px from the Sun
            const desiredMercuryScreenDist = 60;
            camera.x = 0;
            camera.y = 0;
            camera.zoom = desiredMercuryScreenDist / celestialBodies.mercury.distance;
            
            followRocket = false; // On start screen, don't follow rocket
            isStartScreen = true; // Make sure start screen flag is set
            
            // Hide UI during start screen
            document.getElementById('ui').classList.add('hidden');
            document.getElementById('instructions').classList.add('hidden');
            
            // Show start screen initially
            document.getElementById('start-screen').style.display = 'block';
            document.getElementById('start-screen').style.opacity = '1';
            
            // Log initialization info for debugging
            console.log('Initialization complete:');
            console.log('- Canvas size:', canvas.width, 'x', canvas.height);
            console.log('- Initial camera zoom:', camera.zoom);
            console.log('- Neptune distance:', celestialBodies.neptune.distance.toExponential(2));
            console.log('- Rocket position:', positionX.toExponential(2), positionY.toExponential(2));
            console.log('- Earth position:', celestialBodies.earth.x.toExponential(2), celestialBodies.earth.y.toExponential(2));
            
            // Test drawing the Sun to center of screen to verify worldToScreen works
            const sunScreenPos = worldToScreen(0, 0);
            console.log('- Sun screen position:', sunScreenPos.x.toFixed(1), sunScreenPos.y.toFixed(1));
            
            // Start the game loop immediately
            lastTime = performance.now();
            gameLoop(lastTime);
            
            setInterval(handleInput, 16);
        }

        window.addEventListener('resize', resizeCanvas);
        
        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing...');
            init();
        });
        
        // Fallback initialization if DOMContentLoaded already fired
        if (document.readyState !== 'loading') {
            console.log('DOM already loaded, initializing immediately...');
            init();
        }
    </script>
</body>
</html>